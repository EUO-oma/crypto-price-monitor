<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firebase ë°ì´í„° ë””ë²„ê·¸</title>
    <style>
        body {
            font-family: monospace;
            background: #000;
            color: #0f0;
            padding: 20px;
        }
        pre {
            background: #111;
            padding: 20px;
            border: 1px solid #0f0;
            overflow: auto;
            max-height: 600px;
        }
        button {
            background: #0f0;
            color: #000;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }
        .error { color: #f00; }
        .success { color: #0f0; }
    </style>
</head>
<body>
    <h1>ğŸ” Firebase ë°ì´í„° êµ¬ì¡° í™•ì¸</h1>
    
    <button onclick="checkFirebaseData()">Firebase ë°ì´í„° í™•ì¸</button>
    <button onclick="checkPricesStructure()">ê°€ê²© ë°ì´í„° êµ¬ì¡° í™•ì¸</button>
    <button onclick="migrateDataStructure()">ë°ì´í„° êµ¬ì¡° ë§ˆì´ê·¸ë ˆì´ì…˜</button>
    
    <pre id="output"></pre>

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    
    <script>
        // Firebase ì„¤ì •
        const firebaseConfig = {
            apiKey: "AIzaSyA6zB_snzOh_e5tG6_-uK64g6dwL5pzU4c",
            authDomain: "crypto-monitor-84bdb.firebaseapp.com",
            databaseURL: "https://crypto-monitor-84bdb-default-rtdb.firebaseio.com",
            projectId: "crypto-monitor-84bdb",
            storageBucket: "crypto-monitor-84bdb.firebasestorage.app",
            messagingSenderId: "146592267275",
            appId: "1:146592267275:web:916c54658889be5dab9b0e",
            measurementId: "G-TTGCF3YWWJ"
        };
        
        let database;
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        database = firebase.database();
        
        const output = document.getElementById('output');
        
        function log(message, data = null) {
            output.innerHTML += message + '\n';
            if (data) {
                output.innerHTML += JSON.stringify(data, null, 2) + '\n';
            }
            output.innerHTML += '\n';
        }
        
        async function checkFirebaseData() {
            output.innerHTML = '';
            log('Firebase ì „ì²´ ë°ì´í„° êµ¬ì¡° í™•ì¸ ì¤‘...');
            
            try {
                const snapshot = await database.ref('/').once('value');
                const data = snapshot.val();
                
                if (!data) {
                    log('ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤!', 'error');
                    return;
                }
                
                log('ìµœìƒìœ„ í‚¤ë“¤:', Object.keys(data));
                
                // prices êµ¬ì¡° í™•ì¸
                if (data.prices) {
                    const pricesKeys = Object.keys(data.prices);
                    log(`prices í•˜ìœ„ í‚¤ ê°œìˆ˜: ${pricesKeys.length}`);
                    log('prices ì²« 5ê°œ í‚¤:', pricesKeys.slice(0, 5));
                    
                    // ì²« ë²ˆì§¸ í•­ëª© êµ¬ì¡° í™•ì¸
                    const firstKey = pricesKeys[0];
                    log(`ì²« ë²ˆì§¸ í•­ëª© (${firstKey}) êµ¬ì¡°:`, data.prices[firstKey]);
                }
                
            } catch (error) {
                log('ì—ëŸ¬:', error.message);
            }
        }
        
        async function checkPricesStructure() {
            output.innerHTML = '';
            log('ê°€ê²© ë°ì´í„° ìƒì„¸ êµ¬ì¡° í™•ì¸ ì¤‘...');
            
            try {
                const snapshot = await database.ref('prices').once('value');
                const prices = snapshot.val();
                
                if (!prices) {
                    log('prices ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤!');
                    return;
                }
                
                // ë°ì´í„° êµ¬ì¡° ë¶„ì„
                const keys = Object.keys(prices);
                log(`ì´ ${keys.length}ê°œì˜ í•­ëª©`);
                
                // ë‚ ì§œ í˜•ì‹ì¸ì§€ í™•ì¸
                const datePattern = /^\d{4}-\d{2}-\d{2}$/;
                const isDateKeys = keys.every(key => datePattern.test(key));
                
                if (isDateKeys) {
                    log('âœ… ë‚ ì§œ í‚¤ êµ¬ì¡° (YYYY-MM-DD)');
                    
                    // ìµœê·¼ ë‚ ì§œ ë°ì´í„° í™•ì¸
                    const sortedDates = keys.sort((a, b) => b.localeCompare(a));
                    const recentDate = sortedDates[0];
                    log(`ìµœê·¼ ë‚ ì§œ: ${recentDate}`);
                    log('ìµœê·¼ ë‚ ì§œ ë°ì´í„°:', prices[recentDate]);
                } else {
                    log('âŒ ë‚ ì§œ í‚¤ êµ¬ì¡°ê°€ ì•„ë‹˜');
                    
                    // ë‹¤ë¥¸ êµ¬ì¡°ì¸ ê²½ìš°
                    const sampleKey = keys[0];
                    const sampleData = prices[sampleKey];
                    log(`ìƒ˜í”Œ í‚¤: ${sampleKey}`);
                    log('ìƒ˜í”Œ ë°ì´í„°:', sampleData);
                    
                    // í”Œë« êµ¬ì¡°ì¸ì§€ í™•ì¸
                    if (sampleData && sampleData.date) {
                        log('ğŸ“‹ í”Œë« êµ¬ì¡°ë¡œ ì €ì¥ëœ ê²ƒìœ¼ë¡œ ë³´ì„ (ê° í•­ëª©ì— date í•„ë“œ)');
                    }
                }
                
            } catch (error) {
                log('ì—ëŸ¬:', error.message);
            }
        }
        
        async function migrateDataStructure() {
            output.innerHTML = '';
            log('ë°ì´í„° êµ¬ì¡° ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œì‘...');
            
            try {
                const snapshot = await database.ref('prices').once('value');
                const prices = snapshot.val();
                
                if (!prices) {
                    log('ë§ˆì´ê·¸ë ˆì´ì…˜í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤!');
                    return;
                }
                
                const keys = Object.keys(prices);
                const firstData = prices[keys[0]];
                
                // í˜„ì¬ êµ¬ì¡° í™•ì¸
                if (firstData && firstData.date) {
                    log('í”Œë« êµ¬ì¡°ì—ì„œ ë‚ ì§œ ê¸°ë°˜ êµ¬ì¡°ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜...');
                    
                    const newStructure = {};
                    
                    // ë°ì´í„° ì¬êµ¬ì„±
                    Object.values(prices).forEach(item => {
                        if (item.date) {
                            if (!newStructure[item.date]) {
                                newStructure[item.date] = {};
                            }
                            
                            // ì‹¬ë³¼ë³„ë¡œ êµ¬ì„±
                            const symbol = item.symbol || 'UNKNOWN';
                            newStructure[item.date][symbol] = {
                                symbol: symbol,
                                date: item.date,
                                high_price: item.btc_high || item.high_price || item.btc || 0,
                                low_price: item.btc_low || item.low_price || item.btc || 0,
                                price: item.btc || item.price || 0,
                                updated_at: item.collected_at || item.updated_at || new Date().toISOString()
                            };
                            
                            // ETH ë°ì´í„°ê°€ ìˆìœ¼ë©´
                            if (item.eth) {
                                newStructure[item.date]['ETHUSDT'] = {
                                    symbol: 'ETHUSDT',
                                    date: item.date,
                                    high_price: item.eth_high || item.eth,
                                    low_price: item.eth_low || item.eth,
                                    price: item.eth,
                                    updated_at: item.collected_at || new Date().toISOString()
                                };
                            }
                            
                            // SOL ë°ì´í„°ê°€ ìˆìœ¼ë©´
                            if (item.sol) {
                                newStructure[item.date]['SOLUSDT'] = {
                                    symbol: 'SOLUSDT',
                                    date: item.date,
                                    high_price: item.sol_high || item.sol,
                                    low_price: item.sol_low || item.sol,
                                    price: item.sol,
                                    updated_at: item.collected_at || new Date().toISOString()
                                };
                            }
                        }
                    });
                    
                    log('ìƒˆ êµ¬ì¡°:', Object.keys(newStructure).slice(0, 3));
                    
                    // í™•ì¸
                    if (confirm('ì •ë§ë¡œ ë°ì´í„° êµ¬ì¡°ë¥¼ ë§ˆì´ê·¸ë ˆì´ì…˜í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                        // ë°±ì—…
                        await database.ref('prices_backup').set(prices);
                        log('âœ… ë°±ì—… ì™„ë£Œ: prices_backup');
                        
                        // ìƒˆ êµ¬ì¡°ë¡œ ë®ì–´ì“°ê¸°
                        await database.ref('prices').set(newStructure);
                        log('âœ… ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ!');
                        log('price-history.html í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ì„¸ìš”.');
                    }
                    
                } else {
                    log('ì´ë¯¸ ì˜¬ë°”ë¥¸ êµ¬ì¡°ì…ë‹ˆë‹¤.');
                }
                
            } catch (error) {
                log('ë§ˆì´ê·¸ë ˆì´ì…˜ ì—ëŸ¬:', error.message);
            }
        }
    </script>
</body>
</html>